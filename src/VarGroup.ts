import { isArray, keys, setReadOnly } from "@alanscodelog/utils"
import { Base } from "Base.js"
import type { InterpolatedVars } from "InterpolatedVars.js"
import { regexVariable } from "types.js"
import type { Var } from "Var.js"

/**
 * Provides a way to group variables under a common prefix, or even serve to alias variables.
 *
 * ```ts
 *
 * const fontFamilySetting = new VarGroup("font-family",
 * 	{
 * 		regular: fontFamilyPrimaryVar,
 * 		heading: fontFamilySecondaryVar,
 * 	}
 * )
 *
 * // fontFamilySetting.values = {
 * //		"font-family-regular": "..."
 * //		"font-family-heading": "..."
 * // }
 * ```
 *
 * They can even take in a variable in a InterpolatedVars instance.
 *
 * const colors = new VarGroup("font-family",
 * 	{
 * 		color-warning: [reds, "5"],
 * 	}
 * )
 */
export class VarGroup<
	T extends Record<string, Var<any, any, any> | [InterpolatedVars<any, any, any>, string]>,
> extends Base<T> {
	value!: Record<string, string>
	// eslint-disable-next-line @typescript-eslint/prefer-readonly
	private _ready: boolean = false
	constructor(
		name: VarGroup<T>["name"],
		value: T,
		separator?: string
	) {
		super(name, separator)
		this._checkParams(value)
		setReadOnly(this, "rawValue", {} as T)
		for (const key of keys(value)) {
			this.set(key, value[key])
		}
		this._ready = true
		this._onChange()
	}
	private _checkParams(
		value: T,
	): void {
		for (const key of keys(value)) {
			if (!key.match(regexVariable)) {
				throw new Error(`Invalid variable name: ${key}`)
			}
			const val = value[key]
			if (!isArray(val)) {
				if (this._generateKeys(value).includes(val.name)) {
					throw new Error(`Var name ${val.name} conflicts with a name generated by this instance.`)
				}
			} else {
				// #todo [InterpolatedVars, index] format
			}
		}
	}
	set(key: keyof T, value: Var<any, any, any> | [InterpolatedVars<any>, any]): void {
		this._checkParams({ ...this.rawValue, [key]: value })
		this.remove(key)
		this.rawValue[key] = value as any // ???
		this.addDependency(isArray(value) ? value[0] : value)
		this._onChange()
		this.notify("change", this.name, key as string, value)
	}
	remove(key: keyof T): void {
		const val = this.rawValue?.[key]
		this.removeDependency(isArray(val) ? val[0] : val)
		delete this.rawValue[key]
		this._onChange()
	}
	get<TKey extends keyof T>(key: TKey): T[TKey] {
		return this.rawValue[key]
	}
	private _generateKeys(values: Record<string, any>): string[] {
		return keys(values).map(key => `${this.name}-${key}`)
	}
	protected override _onChange(): void {
		if (!this._ready) return
		const raw = this.rawValue
		const res: Record<string, any> = {}
		for (const key of keys(raw)) {
			const val = raw[key]
			if (isArray(val)) {
				const values = val[0].value
				const name = val[0].name
				const css = values[`${name}${this.separator}${val[1]}`]
				res[`${this.name}${this.separator}${key}`] = css
			} else {
				if (val.options.hide) continue
				const css = val.value
				const cssKey = keys(css)[0]
				res[`${this.name}${this.separator}${key}`] = css[cssKey]
			}
		}
		this.value = res
	}
}
